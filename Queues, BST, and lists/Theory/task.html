<div class="step-text">
<p>In object-oriented programming, we often deal with objects (hence the name). Because of this, programmers have come up with several unique ways to store and access data. First, we learn about the most primitive form, <strong>variables</strong>, which let us name the objects we create using the <code class="language-java">new</code><strong> </strong>keyword. The next step is <strong>arrays, </strong>a collection of variables of the same type. These two methods don't offer any kind of flexibility, however, we are not limited to them: we also have access to different data structures.</p><p><strong>ArrayList, LinkedList, Stack</strong> are some of the examples of the built-in classes Java offers us. Each of these is a container that holds variables, or sometimes other containers. They each have unique ways of accessing and modifying the data stored in them. It is important to know how they work because it enables us to maximize our coding efficiency and create more streamlined and effective solutions.</p><h5 id="array-list">Array list</h5><p>By now you should have some idea of how arrays work. They have a predetermined size which can't be changed, which causes a few limitations. ArrayList<strong> </strong>is a simple structure that works similarly to an array, however, its limitations are removed after initialization and its size can be modified.</p><pre><code class="language-java">public static void main(String[] args) {
    ArrayList&lt;T&gt; arrayList = new ArrayList&lt;T&gt;();
    T element = new T();
    //T can be replaced by any type which is not primitive.

    arrayList.add(element); 
    //Adds an element to the ArrayList and returns true if successful.

    arrayList.get(0); 
    //Returns the element on the specified index
        
    arrayList.indexOf(element); 
    //Returns the index of the specified object, or -1 if the ArrayList doesn't contain the object

    arrayList.remove(element); 
    //Removes an element and returns true if successful
}</code></pre><p>The methods above are used to manipulate and access the ArrayList<strong>, </strong>so let's discuss how exactly they work and what their <strong>time complexities </strong>look like. If you don't remember what time complexities are you can click here to refresh your memory.</p><ul><li><p><code class="language-java">add(E element)</code>: this method adds an element to the end of the ArrayList. The time complexity is <code class="language-java">O(1)</code> on average. However, if the ArrayList needs to resize its internal array to accommodate the new element, the time complexity becomes <code class="language-java">O(n)</code>, where n is the current size of the ArrayList. This is because resizing involves creating a new array and copying the existing elements.</p></li><li><p><code class="language-java">get(int index)</code>: this method retrieves the element at the specified index from the ArrayList. The time complexity is <code class="language-java">O(1)</code> because accessing an element by its index in an ArrayList is a constant-time operation.</p></li><li><p><code class="language-java">indexOf(Object o)</code>: this method returns the index of the first occurrence of the specified element in the ArrayList. The time complexity is <code class="language-java">O(n)</code> because it may need to iterate through the ArrayList to find the element. In the worst case, it needs to search through all elements.</p></li><li><p><code class="language-java">remove(int index)</code>: this method removes the element at the specified index from the ArrayList. The time complexity is <code class="language-java">O(n - index)</code> because it may require shifting the subsequent elements to fill the gap left by the removed element. If the element to remove is at the end of the ArrayList, the time complexity is <code class="language-java">O(1)</code>.</p></li></ul><p>It's important to note that these time complexities assume that the ArrayList is not sorted. If it is sorted, some operations like searching (using <code class="language-java">indexOf</code> or <code class="language-java">contains</code>) can be optimized by using binary search, resulting in a time complexity of <code class="language-java">O(log n)</code>.</p><h5 id="stack">Stack</h5><p>The <strong>stack</strong> behaves in a very simple manner. It is as if you were stacking books on a bookshelf. First, to start stacking, we should build a bookshelf... duh.</p><p style="text-align: center;"><picture><img alt="empty stack" height="301" src="https://ucarecdn.com/9b99a95f-12e3-4ef0-b975-2b4e618b4812/" width="125"/></picture></p><pre><code class="language-java">Stack&lt;Book&gt; bookshelf = new Stack&lt;Book&gt;();</code></pre><p>In this code, a new stack<strong> </strong>is created with the <code class="language-java">new</code> keyword. The angle brackets surrounding the word "Book" let us define what type of objects will be stored in our container, which in this case are books.</p><p>After building the bookshelf, we can <strong>push </strong>some books into it.</p><p style="text-align: center;"><picture><img alt="stack push" height="320" src="https://ucarecdn.com/f925f998-9ce8-4c2c-ad6f-8dd07cd2efb8/" width="450"/></picture></p><pre><code class="language-java">bookshelf.push(book1)
bookshelf.push(book2)
bookshelf.push(book3)</code></pre><p>Here we use the Stack's built-in method <code class="language-java">.push(T object)</code><strong> </strong>to append an object, which must have the same type as declared while creating the stack.</p><p>Unfortunately, since our bookshelf is vertical we can only <strong>pop </strong>out the book that was pushed in last.</p><p style="text-align: center;"><picture><img alt="stack pop" height="368" src="https://ucarecdn.com/9401abf3-ee26-42fd-821f-208b4d23c9f8/" width="150"/></picture></p><pre><code class="language-java">Book lastBook = bookshelf.pop();</code></pre><p>Here we use another built-in Stack method <code class="language-java">.pop()</code><strong> </strong>which removes the element which was inserted last and returns it. This kind of removal is called <strong>LIFO </strong>or <strong>FILO, </strong>which stands for Last In First Out or First In Last Out respectively.</p><p>Of course, we can interact with our bookshelf in other ways:</p><ul><li><p>We can take a <strong>peek</strong> at the book which is placed last without taking it out with the <code class="language-java">.peek()</code> method.</p><pre><code class="language-java">Book lastBook = bookshelf.peek();</code></pre><p>The <code class="language-java">.peek()</code> method returns the last element of the Stack without changing the Stack.</p></li><li><p>We can check if it's <strong>empty</strong> with the <code class="language-java">.IsEmpty()</code> method.</p><pre><code class="language-java">boolean isItEmpty = bookshelf.isEmpty();</code></pre><p>This method returns a boolean value, which is true if the Stack is empty, and false otherwise. </p></li></ul><p>The time complexities of all the aforementioned methods are <code class="language-java">O(1)</code> , meaning that each operation requires the same amount of time. That pretty much covers the <code class="language-java">Stack</code> class.</p><h5 id="stacking-challenge">Stacking challenge</h5><p>Now that you've armed yourself with knowledge, let's tackle some coding problems. You may have heard of the <a href="https://leetcode.com/problems/valid-parentheses/" rel="noopener noreferrer nofollow" target="_blank">valid parentheses problem</a>. Here's how it goes:</p><p>"Given a string <code class="language-java">s</code> containing just the characters <code class="language-java">'('</code>, <code class="language-java">')'</code>, <code class="language-java">'{'</code>, <code class="language-java">'}'</code>, <code class="language-java">'['</code> and <code class="language-java">']'</code>. Determine if the input string is valid".</p><p>An input string is valid if:</p><ol><li><p>Open brackets must be closed by the same type of brackets.</p></li><li><p>Open brackets must be closed in the correct order.</p></li><li><p>Every close bracket has a corresponding open bracket of the same type.</p></li></ol><p>An example of a valid input string would be "{ { [ ( ) ] } }", where each opening bracket is accompanied by a closing one of its type. </p><p>We could use the string's built-in methods and iterate over the characters one by one, using some sort of double pointers, or we could use one of the books from our bookshelf. </p><pre><code class="language-java">public boolean isValid(String s) {
    Stack&lt;Character&gt; stack = new Stack&lt;&gt;();
    for (char c : s.toCharArray()) {
        if (c == '(' || c == '{' || c == '[') {
            stack.push(c);
        } else {
            if (stack.empty()) {
                return false;
            }
            if (c == ')' &amp;&amp; stack.peek() == '(') {
                stack.pop();
            } else if (c == '}' &amp;&amp; stack.peek() == '{') {
                stack.pop();
            } else if (c == ']' &amp;&amp; stack.peek() == '[') {
                stack.pop();
            } else {
                return false;
            }         
        }     
    }
    return stack.empty();
}
</code></pre><p>The <code class="language-java">Stack</code> data structure is perfect for this problem because of how easy it is to add and remove elements from it. The code works like this:</p><ol><li><p>The code goes through each character in the string.</p></li><li><p>If the character is an opening bracket, such as (, {, or [, it is added to the stack.</p></li><li><p>If the character is a closing bracket, such as ), }, or ], the code checks if the stack is empty. If it is, there is no matching opening bracket, so the string is invalid.</p></li><li><p>If the stack is not empty, the code compares the closing bracket with the top element of the stack. If they match, for example, ) matches with (, } matches with {, or ] matches with [, â€“ the top element is removed from the stack.</p></li><li><p>If the closing bracket doesn't match the top element of the stack, the string is invalid.</p></li><li><p>After checking all the characters in the string, if the stack is empty, it means that all opening brackets had matching closing brackets, so the string is valid.</p></li><li><p>If there are remaining opening brackets in the stack, the string is invalid.</p></li></ol><p>To sum up, this code uses a stack to ensure that opening and closing brackets in a string are properly balanced. If all brackets are matched correctly, it returns true; otherwise, it returns false.</p><p>The time complexity of the code is <code class="language-java">O(n)</code> because it iterates through each character in the string once. The space complexity is also <code class="language-java">O(n)</code> because the stack can store up to <code class="language-java">n</code> opening parentheses in the worst-case scenario.</p><h5 id="linked-list">Linked list </h5><p>Now let's move on from our vertical bookshelf and tackle another type of container. A<strong> linked list </strong>can be looked at as a chain of information. Each element of a linked list stores information just like the other data structures, but additionally, it stores a reference<strong> </strong>to the element in front of it. We call the elements of a linked list<strong> nodes. </strong>Here's a quick look at how nodes<strong> </strong>function.</p><pre><code class="language-java">class Node&lt;T&gt; { //T can be replaced with any type, which is not primitive
    public T value; //The information stored within a node
    public Node&lt;T&gt; next; //The next element in the list
    
    public Node(T value) {
        this.value = value;
    }
    
    public Node(T value, Node&lt;T&gt; next) {
        this.value = value;
        this.next = next;
    }
    public Node(){
        
    }
}</code></pre><p>You may have noticed that we have three separate constructors. This is because the first allows us to create a <code class="language-java">Node</code> without specifying its successor. In the second, both the value and the next nodes are necessary. And the third constructor doesn't require any additional input.</p><p>With that, let's implement this diagram:</p><p style="text-align: center;"><picture><img alt="linked list" height="140" src="https://ucarecdn.com/fdc599a2-8e61-4aa8-8be0-5a1a357e786b/" width="750"/></picture></p><pre><code class="language-java">public static void main(String[] args) {
    T value = new T();

    Node&lt;T&gt; head = new Node&lt;&gt;(); // Head has no value
    Node&lt;T&gt; node = new Node&lt;&gt;(value); // The value of node is value     
    Node&lt;T&gt; tail = new Node&lt;&gt;(null,head); // The value of tail is null and its next element is head
        
    head.next = node; // We set the next node of head to node
    node.next = tail; // We set the next node of node to tail
}</code></pre><p>The code and the diagram above showcase what's called a <strong>circular linked list</strong>, since the tail node points to the head node. Of course, there are other types of linked lists, both circular and linear.</p><p>It's also important to remember that the removal and addition of elements from the beginning and the end of a linked List require no iterations, which means they are done in constant time or, in terms of time complexity, <code class="language-java">O(1)</code>.</p><h5 id="linking-knowledge-with-programming">Linking knowledge with programming</h5><p>A linked list is one of the more challenging tools to use because it requires quite a bit of recursion to iterate over it. And it is because of that challenging nature it's worth mastering it. </p><p>Let's look at one of the most common problems regarding linked lists: Reverse Linked List.</p><p>The title describes the problem very well, we simply have to reverse the list and return the reversed list, given its head:</p><pre><code class="language-java">public ListNode reverseList(ListNode head) {
    if (head == null) {
        return null;
    }

    ListNode prev = null;
    ListNode current = head;

    while (current != null) {
        ListNode next = current.next;
        current.next = prev;
        prev = current;
        current = next;
    }

    return prev;
}</code></pre><ol><li><p>This function starts by initializing two variables, <code class="language-java">prev</code> and <code class="language-java">current</code>, as <code class="language-java">null</code> and <code class="language-java">head</code>, respectively. These variables are used to keep track of the previous node and the current node during the iteration process.</p></li><li><p>The <code class="language-java">while</code> loop continues as long as the <code class="language-java">current</code> node is not <code class="language-java">null</code>, meaning there are still nodes to process in the original list.</p></li><li><p>Inside the loop, the code performs the following steps:<br/>a. Create a temporary variable <code class="language-java">next</code> and assign it the value of <code class="language-java">current.next</code>. This step stores the reference to the next node in the original list before modifying it. <br/>b. Assign <code class="language-java">prev</code> to <code class="language-java">current.next</code>, effectively reversing the connection of the current node. By doing this, the <code class="language-java">current</code> node is now pointing to the previous node instead of the next node.<br/>c. Move the <code class="language-java">prev</code> pointer one step forward by assigning it the value of <code class="language-java">current</code>. This step allows the <code class="language-java">prev</code> pointer to progress to the next node in the reversed list.<br/>d. Move the <code class="language-java">current</code> pointer one step forward by assigning it the value of <code class="language-java">next</code>. This step moves the <code class="language-java">current</code> pointer to the next node in the original list so that the process can continue.</p></li><li><p>After the loop finishes, the <code class="language-java">prev</code> variable points to the last node in the original list, which is now the first node in the reversed list. This is because the <code class="language-java">prev</code> pointer keeps getting updated to the previous node as we iterate through the list.</p></li><li><p>The function returns the <code class="language-java">prev</code> node, which becomes the new head node of the reversed list.</p></li></ol><p>In a nutshell, the function works by iteratively reversing the connections between nodes. It uses the <code class="language-java">prev</code> and <code class="language-java">current</code> pointers to keep track of the reversed list as it progresses through the original list. By updating the <code class="language-java">next</code> pointers of each node, the function effectively reverses the order of the nodes in the linked list.</p><p>The time complexity of the code is <code class="language-java">O(n)</code> because it visits and modifies each node once, and the space complexity is <code class="language-java">O(1)</code> because it uses a constant amount of extra space.</p><p>This problem demonstrates the difficulty of iterating over a linked list quite well, but now that we know how to do it, let's look at another problem.</p><h5 id="merging-two-sorted-lists">Merging two sorted lists</h5><p>You are given the heads of two sorted linked lists <code class="language-java">list1</code> and <code class="language-java">list2</code>. Merge the two lists into one <strong>sorted</strong> list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list.</p><pre><code class="language-java">public ListNode mergeTwoLists(ListNode list1, ListNode list2) {

    if (list1 != null &amp;&amp; list2 != null) {
        if (list1.val &lt; list2.val) {
            list1.next = mergeTwoLists(list1.next, list2);
            return list1;
        } else {
            list2.next = mergeTwoLists(list1, list2.next);
            return list2;
        }
    }
    if (list1 == null)
        return list2;
    return list1;
}</code></pre><ol><li><p>This function takes two linked lists, <code class="language-java">list1</code> and <code class="language-java">list2</code>, as input and returns a new linked list that contains all the nodes from both lists in sorted order.</p></li><li><p>If both <code class="language-java">list1</code> and <code class="language-java">list2</code> are not <code class="language-java">null</code>, which means nodes are remaining in both lists to be merged. In this case, the code compares the values of the first nodes in both lists.</p></li><li><p>If the value of the first node in <code class="language-java">list1</code> is less than the value of the first node in <code class="language-java">list2</code>, the code:<br/>a. Sets the <code class="language-java">next</code> pointer of <code class="language-java">list1</code> to the result of recursively calling <code class="language-java">mergeTwoLists</code> with the remaining nodes of <code class="language-java">list1</code> (excluding the first node) and <code class="language-java">list2</code>. This step essentially appends the merged list of the remaining nodes to the first node of <code class="language-java">list1</code>.<br/>b. Returns <code class="language-java">list1</code> as the merged list, ensuring that the nodes are sorted in ascending order.</p></li><li><p>If the value of the first node in <code class="language-java">list2</code> is less than or equal to the value of the first node in <code class="language-java">list1</code>, the code:<br/>a. Sets the <code class="language-java">next</code> pointer of <code class="language-java">list2</code> to the result of recursively calling <code class="language-java">mergeTwoLists</code> with <code class="language-java">list1</code> and the remaining nodes of <code class="language-java">list2</code> (excluding the first node). This step appends the merged list of the remaining nodes to the first node of <code class="language-java">list2</code>.<br/>b. Returns <code class="language-java">list2</code> as the merged list, ensuring that the nodes are sorted in ascending order.</p></li><li><p>If one of the lists becomes <code class="language-java">null</code>, indicating that all nodes from that list have been merged, the code returns the other non-null list as the merged list. This step is necessary to include any remaining nodes from the non-null list in the merged result.</p></li><li><p>If both <code class="language-java">list1</code> and <code class="language-java">list2</code> are <code class="language-java">null</code>, indicating that both lists are empty, the code returns <code class="language-java">null</code> to represent an empty list.</p></li></ol><p>In summary, this code recursively merges two sorted linked lists by comparing the values of their nodes and building a new sorted list accordingly. It uses the <code class="language-java">next</code> pointers to connect the nodes in the merged list.</p><p>The time complexity of the code is <code class="language-java">O(n + m)</code> because it processes each node in both lists once. The space complexity is also <code class="language-java">O(n + m)</code> due to the recursion depth and the stack space used by the recursive calls.</p><p>As we have seen with these two examples, traversing and operating on linked lists and their elements is quite troublesome because each element holds a reference to its successor. But what's more troublesome than one reference? Two of them.</p><h5 id="binary-trees">Binary trees</h5><p>A <strong>binary tree</strong> is structurally quite similar to a linked list. However, instead of connecting an object to an object, a binary tree can link an element to two others.</p><p style="text-align: center;"><picture><img alt="binary tree" height="438" src="https://ucarecdn.com/f83232a6-7fb0-4a32-97d2-338d08465a2d/" width="450"/></picture></p><p>We call this diagram a binary tree, or mostly, just a tree. The beginning point of the tree is called a <strong>root. </strong>In this diagram, the nodes<strong> </strong>numbered 2 and 3 are called <strong>sibling nodes, </strong>and the node numbered 1 (aka the root) is their <strong>parent node.</strong> Similarly, 4 and 5 are the <strong>child nodes</strong> of 2, and they are also called <strong>leaf nodes </strong>since they don't have child nodes of their own. This is what their code would look like:</p><pre><code class="language-java">class Node {

    T key;
    Node left, right;

    public Node(T value){
        this.value = value;
        left = right = null;
    }
    public Node(T value, Node left){
        this.value = value;
        this.left = left;
        this.right = null;
    }
    public Node(T value, Node left, Node right){
        this.value = value;
        this.left = left;
        this.right = right;
    }
}</code></pre><p>The <code class="language-java">left </code>and <code class="language-java">right</code> fields of the <code class="language-java">Node</code> class refer to its children. For example, the left field of node 2 on our diagram would be node 4. </p><p>Again, we use three constructors. The first constructor initializes the node with only its value letting us set its children after initialization. The second constructor allows us to set the left child during initialization, and the third allows us to set both. Of course, both values can be changed after initialization, but it is better to do it ahead of time whenever possible.</p><h5 id="tree-traversal">Tree traversal</h5><p>Due to the access to two other elements, the binary tree<strong> </strong>gives us a lot of variety in traversal. Some of these methods include:</p><ul><li><p>Depth First Search (or DFS)<br/>a. Inorder Traversal<br/>b. Preorder Traversal<br/>c. Postorder Traversal</p></li><li><p>Level Order Traversal, or Breadth First Search (BFS)</p></li><li><p>Boundary Traversal</p></li><li><p>Diagonal Traversal</p></li></ul><p>For the purposes of this topic, we will only go over the DFS.</p><p>Here's how the <strong>DFS traversal</strong> works:</p><ol><li><p>Start from the given node (usually the root) of the tree.</p></li><li><p>Visit the current node and perform any desired operations on it. This could include printing the node's value, collecting data, or performing some computations.</p></li><li><p>Recursively traverse the children of the current node in a depth-first manner. This means selecting one child node at a time and repeating the process from step 2.</p></li><li><p>If a child node has no further children (leaf node), or all its children have been visited, backtrack to the parent node and explore the remaining unvisited children.</p></li><li><p>Repeat steps 2 to 4 until all nodes in the tree have been visited.</p></li></ol><p>DFS can be implemented using either a <strong>recursive approach</strong> or an <strong>iterative approach</strong> using a stack.</p><pre><code class="language-java">public void dfsRecursive(TreeNode node) {
    if (node == null) {
        return;
    }
    System.out.println(node.value);
    
    dfsRecursive(node.left);
    dfsRecursive(node.right);
}
</code></pre><p>Recursive approach:</p><ol><li><p>Implement a recursive function (let's call it <code class="language-java">dfsRecursive</code>) that takes a node as input.</p></li><li><p>Base case: if the input node is <code class="language-java">null</code>, return.</p></li><li><p>Visit the current node and perform any desired operations (in this case, we simply print its value).</p></li><li><p>Recursively call <code class="language-java">dfsRecursive</code> for each child of the current node.</p></li></ol><pre><code class="language-java">public void dfsIterative(TreeNode root) {
    if (root == null) {
        return;
    }

    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
    stack.push(root);

    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        
        System.out.println(node.val);

        if (node.right != null) {
            stack.push(node.right);
        }

        if (node.left != null) {
            stack.push(node.left);
        }
    }
}
</code></pre><p>Iterative approach using Stack:</p><ol><li><p> Create an empty stack and push the root node onto the stack.</p></li><li><p> While the stack is not empty:</p><ul><li><p>   Pop the top node from the stack.</p></li><li><p>   Visit the popped node and perform any desired operations (in this case, we just print its value).</p></li><li><p>   Push all the children of the popped node onto the stack (in reverse order if applicable).</p></li></ul></li><li><p> Repeat step 2 until the stack is empty.</p></li></ol><p>DFS traversal explores the tree in a depth-first manner, prioritizing the exploration of one branch before moving on to the next branch. This approach is useful for tasks such as searching, pathfinding, and tree analysis.</p><h5 id="binary-problems">Binary problems</h5><p>Now that you can easily traverse a binary tree let's put our knowledge to the test and have a look at the Merge Two Binary Trees problem.</p><p>"You are given two binary trees <code class="language-java">root1</code> and <code class="language-java">root2</code>.</p><p>Suppose that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, you sum node values up as the new value of the merged node. Otherwise, the non-null node will be used as the node of the new tree".</p><pre><code class="language-java">public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
    if (root1 == null) return root2;
    if (root2 == null) return root1;
    root1.val += root2.val;
    root1.left = mergeTrees(root1.left, root2.left);
    root1.right = mergeTrees(root1.right, root2.right);
    return root1;
}</code></pre><ol><li><p>The first two <code class="language-java">if</code> statements check if either <code class="language-java">root1</code> or <code class="language-java">root2</code> is <code class="language-java">null</code>. If one of them is <code class="language-java">null</code>, it means there are no more nodes in that tree to merge, so the code returns the non-null tree. This handles the base case for recursion.</p></li><li><p>If neither <code class="language-java">root1</code> nor <code class="language-java">root2</code> is <code class="language-java">null</code>, the code proceeds to merge the nodes. It adds the values of <code class="language-java">root1</code> and <code class="language-java">root2</code> together and assigns the sum to <code class="language-java">root1.val</code>. This step combines the values of the corresponding nodes from both trees.</p></li><li><p>The code then recursively calls <code class="language-java">mergeTrees</code> for the left child of <code class="language-java">root1</code> and <code class="language-java">root2</code> by passing <code class="language-java">root1.left</code> and <code class="language-java">root2.left</code> as arguments. This step merges the left subtrees.</p></li><li><p>Similarly, the code recursively calls <code class="language-java">mergeTrees</code> for the right child of <code class="language-java">root1</code> and <code class="language-java">root2</code> by passing <code class="language-java">root1.right</code> and <code class="language-java">root2.right</code> as arguments. This step merges the right subtrees.</p></li><li><p>Finally, the function returns <code class="language-java">root1</code> as the merged binary tree.</p></li></ol><p>To recap, the code merges two binary trees by summing up the corresponding nodes. It uses recursion to traverse the trees and combines the values of the nodes. The merging process starts from the roots and propagates down to the leaves of the trees.</p><p>The time complexity of the code is <code class="language-java">O(min(n, m))</code>, where n and m are the number of nodes in <code class="language-java">root1</code> and <code class="language-java">root2</code>, respectively. The code visits each node once, taking into account the smaller tree. The space complexity is also <code class="language-java">O(min(n, m))</code>, considering the recursion depth and the stack space used by the recursive calls.</p><h5 id="conclusion">Conclusion</h5><p>In this topic, you have explored the vast diversity of data structures in Java. This is, however, only the tip of the iceberg since there are quite a bit more. Let's summarize what we have just covered.</p><ul><li><p>ArrayList<strong> </strong>is a flexible data structure that can store elements of any nonprimitive type. It behaves similarly to an array, the main difference being the ability to resize.</p></li><li><p>Stack<strong> </strong>is a data structure that follows the Last-In-First-Out (LIFO) principle. The addition and removal of elements are efficient and simple and both have <code class="language-java">O(1)</code> time complexity.</p></li><li><p>LinkedList is a data structure consisting of nodes that store values and references to the next node. It's very versatile but at the same time difficult to master. The time complexity of reversing a linked list is <code class="language-java">O(n)</code>. </p></li><li><p>Binary tree<strong> </strong>works similarly to a linked list but, instead of elements storing a reference to a single successor, they hold a reference to two. The first node of a tree<strong> </strong>is called the root<strong>.</strong> Each node<strong> </strong>may only have two child<strong> </strong>nodes. If it has two children, they are called sibling nodes. </p></li><li><p>There are a lot of traversal methods. In this topic, you learned about the DFS<strong> </strong>(depth-first search), which works by exploring as far as possible along each branch before backtracking.</p></li></ul><p>If you want to know a little more information, you can find it <a href="https://hyperskill.org/learn/step/5252" rel="noopener noreferrer nofollow" target="_blank">here</a>, <a href="https://hyperskill.org/learn/step/5336" rel="noopener noreferrer nofollow" target="_blank">here</a>, and <a href="https://hyperskill.org/learn/step/17546" rel="noopener noreferrer nofollow" target="_blank">here</a>.</p>
</div>